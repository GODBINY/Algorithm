입력 크기 범위별 추천 시간 복잡도
매우 작은 입력 (N ≤ 10)
추천 시간 복잡도: O(N!), O(N^N), O(2^N)

이 범위에서는 계산 복잡도가 매우 높은 알고리즘도 충분히 실행 가능합니다:

완전 탐색(브루트포스): 모든 가능한 경우를 탐색

순열 알고리즘: 모든 순서를 고려해야 하는 문제

재귀적 백트래킹: 모든 가능성을 탐색하되 불필요한 탐색은 줄이는 방식

입력 크기가 매우 작기 때문에 알고리즘의 효율성보다는 구현의 정확성이 더 중요한 영역입니다.

작은 입력 (N ≤ 20)
추천 시간 복잡도: O(2^N)

이 범위에서는 지수 시간 복잡도를 가진 알고리즘이 적합합니다:

비트마스크 DP: 상태를 비트로 표현하는 동적 프로그래밍

조합 알고리즘: 가능한 모든 조합을 고려

부분집합 열거: 모든 부분집합을 고려해야 하는 문제

N=20일 때 2^N은 약 100만으로, 시간 제한 내에 처리 가능합니다.

중소 규모 입력 (N ≤ 50)
추천 시간 복잡도: O(N^3), O(N^2 log N)

이 범위에서는 다음과 같은 알고리즘이 적합합니다:

MITM(Meet in the Middle): 문제를 두 부분으로 나누어 해결

삼중 반복문: 세 개의 중첩된 반복문을 사용하는 알고리즘

플로이드-워셜: 모든 정점 쌍 간의 최단 경로 계산

중간 규모 입력 (N ≤ 500)
추천 시간 복잡도: O(N^3)

이 범위에서는 세제곱 시간 복잡도의 알고리즘까지 사용 가능합니다:

행렬 체인 곱셈: 행렬 곱셈의 최적 순서를 찾는 알고리즘

3중 반복문: 삼중 반복 구조를 사용하는 알고리즘

플로이드-워셜: 모든 정점 쌍 간의 최단 경로 계산

3차원 DP: 세 가지 상태를 고려하는 동적 프로그래밍

N=500일 때 N^3은 1억 2500만으로, 시간 제한에 근접하지만 대부분의 경우 처리 가능합니다.

중대 규모 입력 (N ≤ 5,000)
추천 시간 복잡도: O(N^2), O(N^2 log N)

이 범위에서는 제곱 시간 복잡도의 알고리즘이 적합합니다:

이중 반복문: 두 개의 중첩된 반복문을 사용하는 알고리즘

단순 DP: 이차원 배열을 사용하는 동적 프로그래밍

삽입 정렬/버블 정렬: 단순하지만 O(N^2)의 시간 복잡도를 가진 정렬 알고리즘

N=5,000일 때 N^2은 2500만으로, 시간 제한 내에 처리 가능합니다.

대규모 입력 (N ≤ 100,000)
추천 시간 복잡도: O(N log N)

이 범위에서는 선형 로그 시간 복잡도의 알고리즘이 적합합니다:

효율적인 정렬 알고리즘: 퀵 정렬, 병합 정렬, 힙 정렬

우선순위 큐: 힙을 이용한 자료구조

다익스트라 알고리즘: 하나의 정점에서 다른 모든 정점까지의 최단 경로

이진 검색 트리: 효율적인 탐색과 삽입, 삭제를 지원하는 자료구조

Mo's 알고리즘: 쿼리 최적화 알고리즘

N=100,000일 때 N log N은 약 160만으로, 시간 제한 내에 충분히 처리 가능합니다.

매우 대규모 입력 (N ≤ 1,000,000)
추천 시간 복잡도: O(N log N)

이 범위에서도 선형 로그 시간 복잡도의 알고리즘이 적합합니다:

효율적인 정렬 알고리즘: 퀵 정렬, 병합 정렬, 힙 정렬

세그먼트 트리: 구간 쿼리를 빠르게 처리하는 자료구조

펜윅 트리(BIT): 구간 합을 효율적으로 계산

최장 증가 부분 수열(LIS): 이진 탐색을 활용한 구현

N=1,000,000일 때 N log N은 약 2천만으로, 시간 제한 내에 처리 가능합니다.

초대규모 입력 (N ≤ 10,000,000)
추천 시간 복잡도: O(N)

이 범위에서는 선형 시간 복잡도의 알고리즘이 적합합니다:

단일 반복문: 한 번의 반복으로 문제 해결

DFS/BFS: 그래프 탐색 알고리즘(인접 리스트 표현 시)

투 포인터: 배열에서 두 개의 포인터를 이용해 문제 해결

슬라이딩 윈도우: 윈도우를 이동시키며 문제 해결

동적 프로그래밍: 피보나치 수열 같은 선형적인 DP

N=10,000,000일 때 N은 천만으로, 시간 제한 내에 처리 가능합니다.

매우 큰 입력 (N > 10,000,000)
추천 시간 복잡도: O(log N), O(1)

이 범위에서는 로그 시간 또는 상수 시간 복잡도의 알고리즘이 필요합니다:

이진 탐색: 정렬된 배열에서 값을 찾는 효율적인 알고리즘

수학적 공식: 직접적인 계산식으로 해결

해싱: 상수 시간에 검색이 가능한 자료구조

그리디 알고리즘: 각 단계에서 최적의 선택을 하는 알고리즘

시간 복잡도 선택의 실용적 가이드
제한 시간이 1초일 경우의 가이드
알고리즘 문제에서 제한 시간이 1초일 경우, 다음과 같은 기준으로 시간 복잡도를 선택할 수 있습니다:

N ≤ 500: O(N^3) 이하인 알고리즘 설계

N ≤ 2,000: O(N^2) 이하인 알고리즘 설계

N ≤ 100,000: O(N log N) 이하인 알고리즘 설계

N ≤ 10,000,000: O(N) 이하인 알고리즘 설계

N > 10,000,000: O(log N) 또는 O(1) 알고리즘 설계

연산 횟수에 따른 시간 복잡도 선택
다른 관점에서는 연산 횟수를 기준으로 시간 복잡도를 선택할 수 있습니다:

O(N): 약 1억 번의 연산까지 가능

O(N log N): 약 1000만 번의 연산까지 가능

O(N^2): 약 10만 번의 연산까지 가능

O(N^3): 약 500번의 연산까지 가능

O(2^N): 약 20번의 연산까지 가능

O(N!): 약 10번의 연산까지 가능

시간 복잡도 분석 전략
효과적인 알고리즘 설계를 위한 시간 복잡도 분석 전략은 다음과 같습니다:

하향식(Top-down) 접근법
주어진 문제의 입력 크기와 시간 제한을 확인합니다.

입력 크기에 적합한 시간 복잡도 범위를 결정합니다.

해당 시간 복잡도 내에서 구현 가능한 알고리즘을 찾습니다.

상향식(Bottom-up) 접근법
문제의 본질을 파악합니다.

문제 해결에 적합한 알고리즘을 선택합니다.

선택한 알고리즘의 시간 복잡도가 입력 크기와 시간 제한에 적합한지 확인합니다.

시간 복잡도 검증
알고리즘의 시간 복잡도를 검증하는 주먹구구 법칙:

"입력의 크기를 시간 복잡도에 대입해서 얻은 반복문 수행 횟수에 대해, 1초당 반복문 수행 횟수가 1억(10^8)을 넘어가면 시간 제한을 초과할 가능성이 있다."
