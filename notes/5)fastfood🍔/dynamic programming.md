### Dynamic Programming (동적 계획법) 이란?

동적 계획법(DP)은 복잡한 문제를 여러 개의 간단한 하위 문제(subproblem)로 나누어 푼 다음, 그 해를 저장하여 동일한 하위 문제가 다시 발생했을 때 재계산 없이 사용하는 문제 해결 기법입니다. 즉, **"기억하며 풀기"**라고 할 수 있습니다.

DP가 성립하려면 두 가지 핵심 속성을 만족해야 합니다.

1.  **겹치는 하위 문제 (Overlapping Subproblems):** 큰 문제와 그 하위 문제들이 동일한 작은 하위 문제들을 반복적으로 포함합니다. DP는 이 반복되는 계산을 피하기 위해 한 번 계산한 결과를 메모리 공간(보통 배열이나 해시 테이블)에 저장(Memoization)합니다.

2.  **최적 부분 구조 (Optimal Substructure):** 큰 문제의 최적해가 그 하위 문제들의 최적해들로 구성될 수 있습니다. 즉, 부분 문제의 최적해를 이용해 전체 문제의 최적해를 구할 수 있습니다.

--- 

### 어떤 문제를 봤을 때 DP로 풀어야 할까?

문제를 보고 DP를 떠올려야 하는 힌트는 다음과 같습니다.

1.  **최적화 또는 경우의 수 문제:** "최대값", "최소값", "최단 경로", "가장 긴...", "~하는 방법의 수" 등 최적의 해나 모든 경우의 수를 구하라는 요구사항이 있을 때 DP를 의심할 수 있습니다.

2.  **문제를 작은 단위로 쪼갤 수 있을 때:** 문제의 상태(state)를 정의할 수 있고, 그 상태를 변화시키는 점화식(recurrent relation)을 세울 수 있을 때 DP로 풀 수 있습니다. 예를 들어, `dp[n]`은 `dp[n-1]`과 `dp[n-2]`의 관계로 표현할 수 있다는 규칙을 찾는 것입니다.

3.  **탐욕법(Greedy)이 통하지 않을 때:** 매 순간의 최적해가 전체의 최적해로 이어지지 않는 경우, 모든 가능성을 고려해야 하므로 DP가 해법이 될 수 있습니다. (예: 거스름돈 동전 종류가 일반적이지 않을 때)

4.  **시간 복잡도를 줄여야 할 때:** 완전 탐색(Brute-force)으로 접근하면 시간 초과가 날 것 같은데, 계산 과정에서 중복이 많이 발생할 것 같을 때 DP를 적용하여 시간 복잡도를 획기적으로 줄일 수 있습니다.

--- 

### JavaScript 예시 코드 (피보나치 수열)

피보나치 수열은 DP의 개념을 설명하는 가장 고전적인 예시입니다. `fib(n) = fib(n-1) + fib(n-2)`라는 점화식에서 `fib(3)`을 구하기 위해 `fib(2)`와 `fib(1)`이 반복적으로 계산되는 **겹치는 하위 문제**가 발생합니다.

#### 1. Top-Down 방식 (Memoization)

재귀 호출을 사용하되, 계산한 값을 저장하여 중복 계산을 피합니다.

```javascript
// 메모리를 위한 배열 (메모이제이션 테이블)
const memo = {};

function fibonacci(n) {
  // 이미 계산한 값이면 바로 반환
  if (n in memo) {
    return memo[n];
  }
  // 기저 사례 (Base Case)
  if (n <= 2) {
    return 1;
  }

  // 계산 결과를 저장하고 반환
  memo[n] = fibonacci(n - 1) + fibonacci(n - 2);
  return memo[n];
}

console.log(fibonacci(10)); // 55
console.log(fibonacci(50)); // 12586269025
```

#### 2. Bottom-Up 방식 (Tabulation)

반복문을 사용하여 가장 작은 문제부터 차례대로 해를 구해 테이블을 채워나갑니다.

```javascript
function fibonacci_tab(n) {
  if (n <= 2) {
    return 1;
  }

  // DP 테이블(배열) 생성
  const dp = new Array(n + 1).fill(0);
  dp[1] = 1;
  dp[2] = 1;

  // 가장 작은 문제부터 차례대로 해결
  for (let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }

  return dp[n];
}

console.log(fibonacci_tab(10)); // 55
console.log(fibonacci_tab(50)); // 12586269025
```
