### Prefix Sum (누적 합) 알고리즘 이란?

구간 합(Prefix Sum) 알고리즘은 배열의 특정 구간(range)에 있는 원소들의 합을 매우 효율적으로 계산하기 위한 기법입니다. 이름 그대로, 배열의 맨 처음부터 각 인덱스까지의 합을 미리 계산하여 **'누적 합 배열(Prefix Sum Array)'**을 만들어두는 것이 핵심입니다.

**어떻게 동작하는가?**

1.  **누적 합 배열 생성:** 원본 배열 `A`가 있을 때, 새로운 배열 `P`를 만듭니다. `P[i]`는 `A[0]`부터 `A[i]`까지의 합을 저장합니다. (보통 `P[i] = P[i-1] + A[i]`의 점화식으로 간단히 계산)

2.  **구간 합 계산:** 원본 배열 `A`의 `i`번째 인덱스부터 `j`번째 인덱스까지의 합을 구하고 싶다면, 미리 계산해 둔 누적 합 배열을 이용합니다. `(A[i] + ... + A[j])`는 `(A[0] + ... + A[j]) - (A[0] + ... + A[i-1])`과 같습니다. 즉, `P[j] - P[i-1]`을 계산하면 단 한 번의 뺄셈 연산(O(1))으로 구간 합을 구할 수 있습니다.

--- 

### 어떤 문제를 봤을 때 구간 합을 써야 할까?

문제를 보고 구간 합 알고리즘을 떠올려야 하는 경우는 매우 명확합니다.

1.  **고정된 배열에서 구간 합을 반복적으로 조회할 때:** 가장 전형적인 사용 사례입니다. 배열의 내용은 변하지 않는데, "i부터 j까지의 합은?", "x부터 y까지의 합은?" 과 같이 여러 번의 구간 합 질의(query)가 주어지는 문제입니다. 매번 for문을 돌려 구간 합을 계산하면 (질의 횟수 * 구간 길이) 만큼의 시간이 걸리지만, 구간 합 알고리즘을 사용하면 O(N)의 전처리 후 모든 질의를 O(1)에 처리할 수 있습니다.

2.  **"연속된 부분 배열의 합"과 관련된 문제:** "부분 배열의 합이 K의 배수가 되는 경우의 수는?", "부분 배열의 합이 0이 되는 구간은?" 등 연속된 부분 배열의 합에 대한 조건을 다루는 문제에서 구간 합 배열은 매우 유용한 도구가 됩니다. 예를 들어, `P[j] - P[i-1]`이 K의 배수라는 것은 `P[j]`와 `P[i-1]`을 K로 나눈 나머지가 같다는 의미로 변환하여 풀 수 있습니다.

3.  **2차원 배열에서의 구간 합:** 2차원 배열(행렬)에서도 동일한 아이디어를 확장할 수 있습니다. `(x1, y1)`부터 `(x2, y2)`까지의 사각형 영역의 합을 구하는 문제 역시 2차원 누적 합 배열을 만들어두면 O(1)에 계산할 수 있어, 이미지 처리나 게임 맵 관련 문제에서 유용하게 쓰입니다.

--- 

### JavaScript 예시 코드

#### 1차원 배열에서의 구간 합

```javascript
/**
 * 1차원 배열의 구간 합을 효율적으로 계산하는 클래스
 */
class PrefixSum1D {
  /**
   * @param {number[]} arr 원본 숫자 배열
   */
  constructor(arr) {
    this.prefixSum = new Array(arr.length + 1).fill(0);

    // 누적 합 배열 생성 (O(N))
    // 인덱스를 1부터 시작하면 계산이 편리해짐
    for (let i = 0; i < arr.length; i++) {
      this.prefixSum[i + 1] = this.prefixSum[i] + arr[i];
    }
  }

  /**
   * from 인덱스부터 to 인덱스까지의 구간 합을 반환 (인덱스는 0부터 시작)
   * @param {number} from 시작 인덱스
   * @param {number} to 끝 인덱스
   * @returns {number} 구간 합
   */
  query(from, to) {
    if (from < 0 || to >= this.prefixSum.length - 1 || from > to) {
      throw new Error("Invalid range");
    }
    // P[to+1] - P[from] (인덱스 조정)
    return this.prefixSum[to + 1] - this.prefixSum[from];
  }
}

// 사용 예시
const originalArray = [10, 20, 30, 40, 50];
const ps = new PrefixSum1D(originalArray);

// 누적 합 배열: [0, 10, 30, 60, 100, 150]
console.log(ps.prefixSum);

// 1번 인덱스부터 3번 인덱스까지의 합 (20 + 30 + 40)
console.log(`Sum from index 1 to 3: ${ps.query(1, 3)}`); // 90

// 0번 인덱스부터 4번 인덱스까지의 합 (전체 합)
console.log(`Sum from index 0 to 4: ${ps.query(0, 4)}`); // 150

// 2번 인덱스부터 2번 인덱스까지의 합 (30)
console.log(`Sum from index 2 to 2: ${ps.query(2, 2)}`); // 30
```
