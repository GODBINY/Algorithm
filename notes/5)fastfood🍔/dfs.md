네, DFS(깊이 우선 탐색)에 대해 설명해 드리겠습니다. 코딩 테스트에서 어떤 문제를 DFS로 풀어야 할지 감을 잡는 방법과 함께 JavaScript 예시 코드를 제공해 드릴게요.

### DFS (Depth-First Search, 깊이 우선 탐색) 란?

DFS는 그래프나 트리 구조를 탐색하는 알고리즘 중 하나입니다. 이름 그대로 **'깊이를 우선'**으로 탐색합니다.

가장 쉬운 비유는 **"한 우물만 파는 것"** 또는 **"미로 찾기"**입니다.

1.  **일단 갈 수 있는 길 끝까지 가본다.** (한 경로를 최대한 깊게 파고든다)
2.  **더 이상 갈 길이 없으면 (막다른 길이면), 바로 이전 갈림길로 돌아온다.** (Backtrack)
3.  **돌아온 갈림길에서 아직 가보지 않은 다른 길이 있다면, 그 길로 다시 끝까지 가본다.**
4.  모든 길을 다 방문할 때까지 이 과정을 반복한다.

이 "돌아가기" 과정을 위해 DFS는 내부적으로 **스택(Stack)** 자료구조를 사용합니다. (재귀 함수를 사용하면 호출 스택이 이 역할을 자동으로 해줍니다.)

---

### 어떤 문제를 봤을 때 DFS로 풀어야 할까?

문제를 보고 "이건 DFS 문제다!"라고 판단하는 힌트는 다음과 같습니다.

#### 1. "모든 경우의 수"를 탐색해야 할 때

-   **문제 유형:** 특정 조건을 만족하는 **모든** 조합, 순열, 경로 등을 찾아야 하는 문제.
-   **핵심 단어:** "모든 경로", "모든 조합", "경우의 수"
-   **사고 과정:** "하나의 경로를 쭉 따라가서 끝까지 탐색해보고, 아니면 다시 돌아와서 다른 경로를 시도해봐야겠다." 라는 생각이 들면 DFS입니다. 백트래킹(Backtracking) 기법이 바로 DFS를 활용한 대표적인 예시입니다.
-   **예시:**
    -   N개의 숫자로 만들 수 있는 모든 순열 찾기
    -   게임 맵에서 시작점에서 도착점까지 가는 모든 경로 찾기
    -   N-Queens 문제, 스도쿠 풀이

#### 2. "연결 요소(Connected Components)"를 찾아야 할 때

-   **문제 유형:** 그래프가 몇 개의 덩어리로 나뉘어 있는지, 특정 노드와 연결된 모든 노드를 찾아야 하는 문제.
-   **사고 과정:** "한 점에서 시작해서, 그 점과 연결된 모든 점들을 다 방문 처리하고, 아직 방문 안 한 다른 점에서 또 시작해서 연결된 것들을 묶어야겠다."
-   **예시:**
    -   지도에서 대륙의 개수 세기 (상하좌우로 연결된 땅 덩어리)
    -   네트워크에서 연결된 컴퓨터 그룹의 개수 찾기
    -   "음료수 얼려 먹기", "단지 번호 붙이기" 같은 코딩 테스트 단골 문제

#### 3. "경로의 존재 여부"만 확인하면 될 때

-   **문제 유형:** 시작점에서 도착점까지 가는 길이 **있는지 없는지**만 확인하는 문제. (최단 경로를 찾을 필요는 없음)
-   **사고 과정:** "일단 아무 길이나 하나 잡고 끝까지 가보자. 도착하면 '성공', 막다른 길만 계속 만나면 '실패'."
-   **예시:**
    -   미로 탈출이 가능한지 여부 확인
    -   두 사람이 친구 관계(직간접적으로 연결)인지 확인

**⚠️ 중요: "최단 경로"를 찾아야 한다면?**
"최단 거리", "최소 비용", "최소 횟수"를 묻는 문제는 DFS가 아닌 **BFS(너비 우선 탐색)**를 사용해야 합니다. DFS는 가장 먼저 발견한 해가 최적이라는 보장이 없기 때문입니다.

---

### JavaScript 예시 코드 (그래프 탐색)

그래프를 탐색하는 가장 기본적인 DFS 코드입니다. 재귀를 이용한 방식이 직관적이고 많이 쓰입니다.

```javascript
// 그래프는 인접 리스트(Adjacency List)로 표현
const graph = {
  A: ['B', 'C'],
  B: ['A', 'D'],
  C: ['A', 'G', 'H', 'I'],
  D: ['B', 'E', 'F'],
  E: ['D'],
  F: ['D'],
  G: ['C'],
  H: ['C'],
  I: ['C', 'J'],
  J: ['I']
};

/**
 * DFS (깊이 우선 탐색) 함수
 * @param {object} graph - 인접 리스트로 표현된 그래프
 * @param {string} startNode - 탐색을 시작할 노드
 */
function dfs(graph, startNode) {
  const visited = new Set(); // 방문한 노드를 기록하기 위한 Set
  const result = [];         // 탐색 순서를 기록할 배열

  function traverse(node) {
    // 1. 현재 노드가 이미 방문했다면, 함수를 즉시 종료 (무한 루프 방지)
    if (visited.has(node)) {
      return;
    }

    // 2. 현재 노드를 방문 처리하고 결과에 추가
    visited.add(node);
    result.push(node);

    // 3. 현재 노드와 연결된 모든 이웃 노드에 대해
    const neighbors = graph[node] || [];
    for (const neighbor of neighbors) {
      // 4. 재귀적으로 탐색을 계속한다 (깊이 파고들기)
      traverse(neighbor);
    }
  }

  // 시작 노드부터 탐색 시작
  traverse(startNode);

  return result;
}

// 'A'에서 시작하여 DFS 실행
const dfsResult = dfs(graph, 'A');
console.log(dfsResult);
// 출력 예시: [ 'A', 'B', 'D', 'E', 'F', 'C', 'G', 'H', 'I', 'J' ]
// (탐색 순서는 인접 리스트의 순서에 따라 달라질 수 있습니다)
```

### 핵심 요약

-   **언제 쓰는가?** 모든 경로 탐색, 연결 요소 찾기, 경로 존재 여부 확인
-   **어떻게 동작하는가?** 한 길로 끝까지 가보고, 막히면 돌아와서 다른 길로 간다 (스택/재귀)
-   **주의할 점!** 최단 경로 문제는 BFS를 사용하자.