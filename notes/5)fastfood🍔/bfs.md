네, 그럼요. BFS(너비 우선 탐색)에 대해서도 DFS와 비교하며 명확하게 설명해 드릴게요.

### BFS (Breadth-First Search, 너비 우선 탐색) 란?

BFS는 그래프나 트리 구조를 탐색하는 또 다른 핵심 알고리즘입니다. 이름 그대로 **'너비를 우선'**으로, 즉 **가까운 것부터** 탐색합니다.

가장 쉬운 비유는 **"호수에 돌을 던졌을 때 물결이 퍼져나가는 모습"**입니다.

1.  **시작점에서 가장 가까운 노드들(바로 옆 이웃)을 먼저 모두 방문한다.** (1차 물결)
2.  **그다음, 그 이웃 노드들의 이웃들을 모두 방문한다.** (2차 물결)
3.  **이 과정을 마치 동심원이 퍼져나가듯, 모든 노드를 방문할 때까지 반복한다.**

이 "가까운 순서대로" 방문하는 순서를 지키기 위해 BFS는 **큐(Queue)** 자료구조를 사용합니다. (먼저 들어온 것이 먼저 나가는 FIFO - First-In, First-Out 방식)

---

### 어떤 문제를 봤을 때 BFS로 풀어야 할까?

문제를 보고 "이건 BFS 문제다!"라고 확신할 수 있는 가장 강력한 단서가 있습니다.

#### 👑 The Golden Rule: "최단 경로" 또는 "최소 횟수"

문제에서 **가중치 없는 그래프**의 **"최단 거리", "최소 비용", "최소 횟수", "가장 빠른 길"** 등을 찾으라고 한다면, **거의 100% BFS 문제입니다.**

-   **왜?** BFS는 시작점에서부터 거리가 1인 노드, 2인 노드, 3인 노드... 순으로 레벨(level)을 나누어 탐색합니다. 따라서 특정 목적지를 발견했다면, 그 경로는 **가장 적은 간선을 거쳐온 최단 경로임이 보장**됩니다.
-   **사고 과정:** "A에서 B까지 가는 가장 빠른 길을 찾아야 하네? 한 칸씩 주변으로 넓혀가면서 찾아보면 가장 먼저 도착하는 길이 최단 경로겠구나!"
-   **대표 예시:**
    -   미로 탈출 **최단 경로** 찾기
    -   "토마토" 문제 (모든 토마토가 익는 **최소 일수** 구하기)
    -   "숨바꼭질" 문제 (동생을 찾는 **가장 빠른 시간** 구하기)
    -   특정 단어에서 다른 단어로 바꾸는 **최소 변환 횟수** 구하기

DFS는 한 길로 깊게 파고들기 때문에 가장 먼저 찾은 경로가 최단 경로라는 보장이 전혀 없습니다. 하지만 BFS는 가까운 순서대로 샅샅이 훑기 때문에 최단 경로를 보장합니다.

---

### JavaScript 예시 코드 (그래프 탐색)

DFS 예시와 동일한 그래프를 BFS로 탐색하는 코드입니다. 큐(Queue)를 사용하는 것이 핵심적인 차이입니다.

```javascript
// 그래프는 인접 리스트(Adjacency List)로 표현
const graph = {
  A: ['B', 'C'],
  B: ['A', 'D'],
  C: ['A', 'G', 'H', 'I'],
  D: ['B', 'E', 'F'],
  E: ['D'],
  F: ['D'],
  G: ['C'],
  H: ['C'],
  I: ['C', 'J'],
  J: ['I']
};

/**
 * BFS (너비 우선 탐색) 함수
 * @param {object} graph - 인접 리스트로 표현된 그래프
 * @param {string} startNode - 탐색을 시작할 노드
 */
function bfs(graph, startNode) {
  const visited = new Set(); // 방문한 노드를 기록
  const queue = [startNode]; // 탐색할 노드를 담을 큐 (JS 배열로 구현)
  const result = [];         // 탐색 순서를 기록할 배열

  visited.add(startNode); // 시작 노드는 이미 방문한 것으로 처리하고 큐에 넣음

  // 1. 큐가 빌 때까지 루프를 계속한다.
  while (queue.length > 0) {
    // 2. 큐의 맨 앞에서 노드를 하나 꺼낸다 (Dequeue)
    const currentNode = queue.shift();
    result.push(currentNode);

    // 3. 꺼낸 노드와 연결된 모든 이웃 노드에 대해
    const neighbors = graph[currentNode] || [];
    for (const neighbor of neighbors) {
      // 4. 아직 방문하지 않은 이웃이라면
      if (!visited.has(neighbor)) {
        // 5. 방문 처리하고 큐의 맨 뒤에 추가한다 (Enqueue)
        visited.add(neighbor);
        queue.push(neighbor);
      }
    }
  }

  return result;
}

// 'A'에서 시작하여 BFS 실행
const bfsResult = bfs(graph, 'A');
console.log(bfsResult);
// 출력: [ 'A', 'B', 'C', 'D', 'G', 'H', 'I', 'E', 'F', 'J' ]
// 시작점 A -> 레벨1(B,C) -> 레벨2(D,G,H,I) -> 레벨3(E,F,J) 순으로 탐색
```

### 핵심 요약: BFS vs DFS

| 특징 | BFS (너비 우선 탐색) | DFS (깊이 우선 탐색) |
| :--- | :--- | :--- |
| **주요 목표** | **최단 경로, 최소 횟수** | 모든 경로 탐색, 경로 존재 여부 |
| **자료구조** | **큐 (Queue)** | **스택 (Stack) / 재귀 함수** |
| **탐색 방식** | 가깝고 넓게 (물결처럼) | 좁고 깊게 (한 우물 파기) |
| **대표 유형** | 미로 최단거리, 토마토, 숨바꼭질 | 순열/조합, 단지번호붙이기, N-Queens |
